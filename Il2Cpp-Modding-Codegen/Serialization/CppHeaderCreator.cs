using Il2CppModdingCodegen.Config;
using Il2CppModdingCodegen.Data;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Il2CppModdingCodegen.Serialization
{
    public class CppHeaderCreator
    {
        private readonly SerializationConfig _config;
        private readonly CppContextSerializer _serializer;

        internal CppHeaderCreator(SerializationConfig config, CppContextSerializer serializer)
        {
            _config = config;
            _serializer = serializer;
        }

        private bool hasIl2CppTypeCheckInclude;

        private void IncludeIl2CppTypeCheckIfNotAlready(CppStreamWriter writer)
        {
            if (hasIl2CppTypeCheckInclude) return;
            writer.WriteInclude("beatsaber-hook/shared/utils/il2cpp-type-check.hpp");
            hasIl2CppTypeCheckInclude = true;
        }

        internal void Serialize(CppTypeContext context)
        {
            var data = context.LocalType;
            var headerLocation = Path.Combine(_config.OutputDirectory, _config.OutputHeaderDirectory, context.HeaderFileName);
            Directory.CreateDirectory(Path.GetDirectoryName(headerLocation));
            using var ms = new MemoryStream();
            using var rawWriter = new StreamWriter(ms);
            using var writer = new CppStreamWriter(rawWriter, "  ");
            // Write header
            writer.WriteComment($"Autogenerated from {nameof(CppHeaderCreator)}");
            writer.WriteComment("Created by Sc2ad");
            writer.WriteComment("=========================================================================");
            writer.WriteLine("#pragma once");
            // TODO: determine when/if we need this
            // For sizes that are valid, we ALSO want to write with pack of 1
            // Invalid sizes are ignored.

            // Write SerializerContext and actual type
            try
            {
                _serializer.Serialize(writer, context, true);
            }
            catch (UnresolvedTypeException e)
            {
                if (_config.UnresolvedTypeExceptionHandling?.TypeHandling == UnresolvedTypeExceptionHandling.DisplayInFile)
                {
                    writer.WriteComment("Unresolved type exception!");
                    writer.WriteLine("/*");
                    writer.WriteLine(e);
                    writer.WriteLine("*/");
                }
                else if (_config.UnresolvedTypeExceptionHandling?.TypeHandling == UnresolvedTypeExceptionHandling.SkipIssue)
                    return;
                else if (_config.UnresolvedTypeExceptionHandling?.TypeHandling == UnresolvedTypeExceptionHandling.Elevate)
                    throw new InvalidOperationException($"Cannot elevate {e} to a parent type- there is no parent type!");
            }
            // End the namespace
            writer.CloseDefinition();
            hasIl2CppTypeCheckInclude = context.NeedIl2CppUtilsFunctionsInHeader;

            if (data.This.Namespace == "System" && data.This.Name == "ValueType")
            {
                IncludeIl2CppTypeCheckIfNotAlready(writer);
                writer.WriteLine("template<class T>");
                writer.WriteLine("struct is_value_type<T, typename std::enable_if_t<std::is_base_of_v<System::ValueType, T>>> : std::true_type{};");
            }
            var nestedContexts = new Stack<CppTypeContext>(context.NestedContexts.Where(n => n.InPlace));
            while (nestedContexts.TryPop(out var nested))
            {
                CppContextSerializer.DefineIl2CppArgTypes(writer, nested);
                foreach (var innerNested in nested.NestedContexts.Where(n => n.InPlace))
                    nestedContexts.Push(innerNested);
            }

            writer.WriteLine("#include \"beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp\"");
            _serializer.WritePostSerializeMethods(writer, context, true);
            writer.Flush();

            writer.WriteIfDifferent(headerLocation, context);
        }
    }
}